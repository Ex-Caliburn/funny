/*
 1.定义:
　　高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
　　抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
2.使用场景:
　　类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。即将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。
3.使用特点
　　依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。
  　 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。
      在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。
      在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。
4.实现案例
　　依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的:闲着无聊看书。代码如下：
 */

class Person {
  read(book) {
    console.log(book.getContent())
  }
}

class Book {
  getContent() {
    return '书中的故事'
  }
}

let me = new Person()
me.read(new Book())
//　　运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸,报纸的代码如下：

// 　　这时候竟然不能读报纸! 只是将书换成报纸，居然必须要修改Person才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Person，这显然不是好的设计。原因就是Person与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。

class NewsPaper {
  getContent() {
    return '看新闻'
  }
}

// 　　我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：

class IReader {
  getContent(book) {
    return book.getContent()
  }
}

//   　　Person类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：

class Person {
  read(reader) {
    console.log(new.IReader(reader))
  }
}

let me = new Person()
me.read(new Book())
me.read(new NewsPaper())


// 这样修改后，无论以后怎样扩展书籍类，都不需要再修改person类了。这只是一个简单的例子，实际情况中，
// 代表高层模块的person类将负责完成主要的业务逻辑，一旦需要对它进行修改，
// 引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。
// 采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本person类与Book类直接耦合时，
// person类必须等Book类编码完成后才可以进行编码，因为person类依赖于Book类。修改后的程序则可以同时开工，互不影响，
// 因为person与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。
// 现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。
