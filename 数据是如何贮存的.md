# 数据是如何贮存的

## 前言

### JavaScript 是什么类型的语言

要理解一门语言是静态类型还是动态类型，最本质的判断方法是看在什么时间段对类型就行检测，静态类型的语言会在编译阶段就行检测，动态类型的语言会在运行时做类型检测！

比如C/C++是静态语言，会在编译阶段对类型就行检测，如果检测到不合法的语言，编译阶段就会报错！

而JavaScript就是动态语言，编译阶段不会做太多类型检测，而是等到运行时再检测变量的具体类型，这是动态语言性能低于静态语言的一个关键的地方。V8对这种动态性做了大量的优化！

要理解一门语言是弱类型还是强类型，看变量在运行时，是否能够改变类型，比如C/c++/javaScript,都可以在运行时将一种类型的变量，改成另外一种类型的，所以他们是弱类型，而JAVA就不能运行过程中修改变量类型，所以是静态语言！

每种编程语言都具有内建的数据类型，但它们的数据类型常有不同之处，使用方式也很不一样，比如 C 语言在定义变量之前，就需要确定变量的类型，你可以看下面这段 C 代码：

```C
int main()
{
   int a = 1;
   char* b = "极客时间";
   bool c = true;
   return 0;
}
```

上述代码声明变量的特点是：在声明变量之前需要先定义变量类型。我们把这种在使用之前就需要确认其变量数据类型的称为静态语言。

相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。比如我们所讲的 JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。

虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型数据赋予给一个声明好的变量，如：

```C
c = a
```

前面代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，C 编译器会把 int 型的变量悄悄转换为 bool 型的变量，我们通常把这种偷偷转换的操作称为`隐式类型转换`。而支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。在这点上，C 和 JavaScript 都是弱类型语言。

### JavaScript 的数据类型

现在我们知道了，JavaScript 是一种弱类型的、动态的语言。那这些特点意味着什么呢？

- 弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。
- 动态，意味着你可以使用同一个变量保存不同类型的数据。

### 内存空间

![alt](https://static001.geekbang.org/resource/image/62/57/6293f5315a5bafbd3ba00ee732bfbf57.png)

从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。

### 栈空间和堆空间

```js

function foo(){
    var a = "极客时间"
    var b = a
    var c = {name:"极客时间"}
    var d = c
}
foo()
```

当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。那么下面我们来看看，当执行到第 3 行代码时，其调用栈的状态，你可以参考下面这张调用栈状态图：

![alt](https://static001.geekbang.org/resource/image/94/fe/9411221e463a86d043a3461d49c9f1fe.png)

从图中可以看出来，当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以你也可以认为变量 a 和变量 b 的值都是存放在栈中的。

接下来继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候处理的情况就不一样了，JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：

![alt](https://static001.geekbang.org/resource/image/22/bc/22100df5c75fb51037d7a929777c57bc.png)

原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。不过你也许会好奇，为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？

答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：

![alt](https://static001.geekbang.org/resource/image/d7/7b/d7153d003a72dbd0a9ca84b59ac3857b.png)

所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。

![alt](https://static001.geekbang.org/resource/image/51/f5/51127624a725a18a0e12e0f5a7aadbf5.png)

### 再谈闭包

```js

function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```

1. 执行 foo()， 创建foo 创建一个空上下文，编译过程 遇到变量 myName， innerBar 放在环境变量， test1， test2放在词法环境，变量入栈
2. 编译时发现 inner 函数中访问了 myName和test1，会创建一个闭包 closure foo() 存放 myName和test1
3. 返回 innerBar 函数，并且 foo上下文销毁，
4. 含有setName和getName对象，这两个对象里面包含了堆中的closure(foo)的引用。虽然foo执行上下文销毁了，foo函数中的对closure(foo)的引用也断开了，但是setName和getName里面又重新建立起来了对closure(foo)引用。
5. bar.setName("极客邦") 访问 bar的 setName方法，访问 myname 属性，在当前函数环境变量中没有找到，往上找到 closure foo(),找到 myname属性并赋值
6. bar.getName() 于上相同

当执行这段代码的时候，你应该有过这样的分析：由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。

当 foo 函数的执行上下文销毁时，由于 foo 函数产生了闭包，所以变量 myName 和 test1 并没有被销毁，而是保存在内存中，那么应该如何解释这个现象呢？

- 当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。
- 在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。
- 接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。
- 由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。

通过上面的分析，我们可以画出执行到 foo 函数中“return innerBar”语句时的调用栈状态，如下图所示：

![alt](https://static001.geekbang.org/resource/image/f9/db/f9dd29ff5371c247e10546393c904edb.png)

从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用bar.setName或者bar.getName时，创建的执行上下文中就包含了“clourse(foo)”。

总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。

## 总结

chrome 的实现 就是 将需要用到 `Closure` 包放到函数的 `[[Scopes]]`

### 问1

1、从内存模型角度分析执行代码的执行流程第二步看，在堆空间创建closure(foo)对象，它是存储在foo函数的执行上下文中的。
那么closure(foo)创建开始时是空对象，执行第三步的时候，才会逐渐把变量添加到其中。
2、当foo函数执行结束后，foo的执行上下文是不是销毁了？如果销毁了，产生一下两个疑问：
    a、如果foo函数执行上下文销毁了，closure(foo)并没有销毁，那foo函数执行上下文是怎么销毁的呢？就比如销毁一个盒子，盒子毁里，里面的东西应该也是毁掉的
    b、既然closure(foo)既然没有销毁，那它存储在堆中的什么地方呢？必定它所依赖的foo执行上下文已经不存在了

### 答1

关于foo函数执行上下文销毁过程：foo函数执行结束之后，当前执行状态的指针下移到栈中的全局执行上下文的位置，foo函数的执行上下文的那块数据就挪出来，这也就是foo函数执行上下文的销毁过程，这个文中有提到，你可以参考“调用栈中切换执行上下文状态“图。

第二个问题：innerBar返回后，含有setName和getName对象，这两个对象里面包含了堆中的closure(foo)的引用。虽然foo执行上下文销毁了，foo函数中的对closure(foo)的引用也断开了，但是setName和getName里面又重新建立起来了对closure(foo)引用。

### 问2

那在其处于闭包对象的条件下，怎么维持这种块级作用域的生效呢？
以下这段代码在chrome里打断点，scope里面是没有生成Closure而是一个Block,请问怎么理解这个问题呢？

```js
function foo() {
      let x = 1
      {
        let x = 2
        function bar(params) {
          return x
        }
      }
      console.log('a', x)
      return bar
    }
    const fn = foo()
    console.log('b', fn())
 ```

### 答2

我看chrome 是生成block ，但是我觉得这是闭包，内部函数和外部函数存在共同的作用域，也是产生私有变量，虽然是block，但是内涵还是闭包

### 字符串很大是否存在栈

字符串，symbol，bigint虽然是原始类型，但是实际还是存放在堆空间的。
比如字符串的大小可能很大，考虑性能还是存放在堆空间。

比如 v8::Number::New 的实现，代码在 src/api/api.cc，里面最终调用了 NewNumber

NewNumber 这个函数在 src/heap/factory-base-inl.h 中，里面最终调用了 NewHeapNumber

所以基础类型在 c++层面依然是存储在堆中的？

### 问3

[[Scopes]] 是v8的实现吧，算是一种优化。ES Spec 当中只提到了函数会对外部词法作用域有一个引用，并没有提闭包变量捕获的问题。记得 V8的这个优化还容易搞出一个 bug，如果父函数内有两个子函数，那他们俩会共用一个 scope 对象来存放捕获的外部变量。而如果其中一个函数当返回值返回了，另一个函数并没有，也会造成根本用不着的变量被一直引用着。

```js
function test (){
let a =1; let b= new Array(100000).fill(0);
let fa = () => a;
let fb = () => b;
return fa;
}
// Closure (test) {a: 1, b: Array(100000)}

```

按理这个大数组不应该被捕获，因为只有 fa 被返回了

### 参考文献

1. [数据是如何贮存的](https://time.geekbang.org/column/article/129596)
2. <https://hashnode.com/post/does-javascript-use-stack-or-heap-for-memory-allocation-or-both-cj5jl90xl01nh1twuv8ug0bjk>
3. https://juejin.cn/post/6957913856488243237#heading-4
