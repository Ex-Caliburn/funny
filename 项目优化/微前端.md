# 微前端

## 前言

随着公司项目越来越多，业务越多，如何在一页面，可以使用其他部门的项目，如何组织代码或者如何实现，这时候 微前端出现

微前端
    一种将独立的前端应用组成一个更大的整体的架构风格

实现方案

- 父级项目通过 iframe 将不同的子项目加载进来
  - iframe 是集成的最简单方式之一。本质上来说，iframe 里的页面是完全独立的，可以轻松构建。而且 iframe 还提供了很多的隔离机制。

- 使用 JS 集成
  - 这种方式可能是最灵活的一种，也是被采用频率最高的一种方法。每个微前端都对应一个 `<script>` 标签，并且在加载时导出一个全局变量。然后，容器应用程序确定应该安装哪些微应用，并调用相关函数以告知微应用何时以及在何处进行渲染。

### 微前端优点

增量升级
简单、解耦的代码库
独立部署
团队自治

### 缺点

#### 下载量

独立构建的 JavaScript 文件可能导致重复的公共依赖，从而增加用户的下载量。例如，如果每个微应用都包括自己的 React 副本，那么用户就得多次下载 React。
这个问题不容易解决，那可以得到缓解。首先，即使我们不做任何优化，每个单独页面的加载速度也有可能比构建单个整体式前端要快。原因是如果独立地编译每个页面，我们就可以有效地进行代码拆分，页面只加载当前页面的依赖项。这可能会导致初始页面加载很快，但随后的导航速度变慢，因为用户被迫在每个页面重新下载相同的依赖项。我们可以对用户常去的页面进行分析，然后单独优化他们的依赖项。
每个项目是不同的，你必须针对性地进行分析。

#### 环境差异

当微应用越来越多，你在本地开发时肯定无法把所有微应用和对应的后端都启动起来，那么你就不得不在本地进行环境的简化。
如果开发环境和生成环境的环境是不同的，这往往会造成问题。所以你需要保证，如果开发者想要完全模拟生成环境，也是可以做到的。只不过会非常耗时。

#### 治理复杂性

微前端作为一个更加分布式的体系结构，将不可避免地要管理更多的东西：更多的代码库、更多的工具、更多的构建管道、更多的服务器、更多的域名等。因此在采用这样的体系结构之前，您需要考虑几个问题：

你是否有足够的自动化措施来配置和管理所需的其他基础架构？
你的前端开发、测试和发布过程是否可以扩展到多个应用程序？
你是否准备好了让决策变得更加分散，甚至难以控制感？
你将如何确保多个独立的前端代码库的质量、一致性和或治理水平？

### 预计目标

将一个大项目拆分成多个小项目，降低项目的维护复杂度
使各个业务最大程度地解耦，当一个业务进行迭代开发，或者多个业务同时进行迭代开发，避免各业务间互相影响，代码冲突等问题。
增量更新，独立部署，快速回滚。当各个业务开发完成或迭代完成后，可以将业务独立部署，无须牵扯其他业务。当上线后发现出现了问题，可以及时回退，不会造成其他不可预知问题。
技术栈无关。当一个项目变得庞大无比之后，强行统一技术栈也许并不是很合适，各个具体业务的目标要求也不一样，也许使用其他技术栈可以更好地去实现业务。
极速打包，优化加载速度。一个项目变得庞大之后，依赖也会越来越多，但这些依赖也许只是某个业务有用，但这些依赖最终都会被打包进项目，造成两个问题，(1) 项目打包速度越来越慢 (2) 打出来的包也越来越大, 浏览器加载速度也越来越慢。

#### 父子项目通信

微前端架构必然是会涉及到数据共享，业务通信。采用 iframe 作为微前端架构，可以使各个项目进行高度的独立，同时 iframe 也可以非常好的使阻止各个项目的JS、CSS间的互相影响；同时采用iframe作为微前端架构，也就意味着我们的所有项目没有必要部署在同一域名下，更直白点说，我们可以引入第三方产品，向外公开一套API，使第三方基于这套API进行开发，引入第三方产品，第三方产品可以自由部署。
这些是iframe的优点，但同时高度的独立，引入第三方产品，也造成项目间信息共享的不方便，域名等的不通也造成了，父项目不能去操作子项目的DOM，子项目不能访问父项目的本地 storage。基于此，我们需要引入一个新的API postMessage ，postMessage是H5引入的新的API，它可以使不同源的脚本可以安全地进行跨源通信，它可以很好支撑起我们父子项目间的信息共享，消息传递。

#### 通过路由进行跨应用程序通信

我们之前提到过 ，应将跨应用通信保持在最低限度。在此示例中，我们唯一的通信是 browser 页面需要告诉 order 页面要加载哪个餐厅。我们使用路由来解决此问题。
涉及到三个 React 应用，都用React Router进行路由，但是以两种略有不同的方式进行初始化。
对于容器应用程序，我们创建一个，它会在内部实例化一个history对象，我们使用该对象来处理客户端历史记录，也可以使用它来将多个React Router 链接在一起。初始化路由的方式为
<Router history={this.props.history}>
复制代码这个 histroy 是由容器应用提供的，所有微应用共用这个 history 对象。这使得用 url 作为消息传递方式变得十分简便。例如，我们有一个像这样的链接：
<Link to={`/restaurant/${restaurant.id}`}>
复制代码单击此链接后，该路径将在容器中更新，该容器将看到新的URL并确定应该安装和呈现餐厅微应用。然后，该微应用自己的路由逻辑将从URL中提取餐厅ID。
我希望这个示例能够显示 URL 的灵活性和强大功能。使用 URL 作为消息传递应该满足一下条件：

- URL 的结构是开放透明的
- URL 的访问权限是全局的
- URL 的长度是有限的
- 面向用户建模，URL 应该易于理解
- 它是声明式的，而不是命令式的。即 URL 表示当前页面的位置，而不是当前页面该做什么
- 它迫使微前端应用进行间接通信，而不是直接依赖

当使用路由作为微前端应用之间的通信方式时，我们选择的路由即构成合同。合同一旦确定，不能轻易修改，所以我们应该进行自动化测试，以检查合同是否得到遵守。

#### Dialog对话框的遮罩覆盖整个屏幕

所以对话框的遮罩要覆盖住全屏，那么 iframe 的宽高就需要和屏幕宽高一样大（准确说是浏览器可视区域）；这里有两个实现方式：

当用户点击新建按钮的时候，给父项目发个消息，让父项目去修改下 iframe 的宽高，然后子项目在同时在给自身添加 padding ，使内容区（表格部分）缩小到红框那个部分。
iframe 的宽高本身就和屏幕宽高相等，子项目给自身添加 padding ，使内容区缩小到红框部分；同时正常情况下，header、aside、面包屑的层级需要高于iframe的层级，如此，iframe 不会阻止这些区域的点击；当用户点了新建按钮，对话框出现的时候，给父项目发送一条消息，让父项目调高 iframe 的层级，如此，遮罩便可以覆盖全屏。

在这里，我最终选择了第二种方案，因为使用第一种方案时，由于 iframe 突然之间的宽高变化，会使得内容区一闪而过的宽高改变，用户体验很不好，所以最后我使用的第二种方案。

## 总结

### 参考文献

1. <https://juejin.cn/post/6844904084600782861>
3. <https://juejin.cn/post/6844904084600782861#heading-8>
