# ==和===

## 前言

### ==

1. ReturnIfAbrupt(x).
2. ReturnIfAbrupt(y).
3. If Type(x) is the same as Type(y), then Return the result of performing Strict Equality Comparison x === y.
4. If x is null and y is undefined, return true.
5. If x is undefined and y is null, return true.
6. If Type(x) is Number and Type(y) is String,return the result of the comparison x == ToNumber(y).
7. If Type(x) is String and Type(y) is Number,return the result of the comparison ToNumber(x) == y.
8. If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.
9. If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).
10. If Type(x) is either String, Number, or Symbol and Type(y) is Object, then return the result of the comparison x == ToPrimitive(y).
11. If Type(x) is Object and Type(y) is either String, Number, or Symbol, then return the result of the comparison ToPrimitive(x) == y.
12. Return false.

ReturnIfAbrupt(x)
// 如果x不是正常值（比如抛出一个错误），中断执行  One of normal, break, continue, return, or throw

```javascript
continue === 0 // Unexpected token '==='
```

当有一边是引用类型时，引用类型会调用 ToPrimitive方法，转换为原始值也就是基本数据类型(非引用数据类型原始值都是它们本身)，然后重新从第一条规则开始比较

由于0的类型是数值，null的类型是Null（这是规格4.3.13小节的规定，是内部Type运算的结果，跟typeof运算符无关）。因此上面的前11步都得不到结果，要到第12步才能得到false。

```javascript
0 == null // false
```

#### ToPrimitive

== 操作ToPrimitive采用一个输入参数和一个可选参数PreferredType。==操作ToPrimitive将其输入参数转换为非Object类型。如果对象能够转换为多个基本类型，则可以使用可选提示PreferredType来支持该类型,

主要是对象类型的操作，采取一下步骤

1. If PreferredType was not passed, let hint be "default".
2. Else if PreferredType is hint String, let hint be "string".
3. Else PreferredType is hint Number, let hint be "number".
4. Let exoticToPrim be GetMethod(input, @@toPrimitive).
5. ReturnIfAbrupt(exoticToPrim).
6. If exoticToPrim is not undefined, then
    1. Let result be Call(exoticToPrim, input, «hint»).
    2. ReturnIfAbrupt(result).
    3. If Type(result) is not Object, return result.
    4. Throw a TypeError exception.
7. If hint is "default", let hint be "number".
8. Return OrdinaryToPrimitive(input,hint).

如果 hint 期望类型没有设置，默认是 "default"，后面hint会转换为"number"，并调用 OrdinaryToPrimitive(input,hint)

#### NOTE

OrdinaryToPrimitive 传入被调用的参数对象(o)，和期望类型(hint)， 采取一下步骤

1. Assert: Type(O) is Object
2. Assert: Type(hint) is String and its value is either "string" or "number".
3. If hint is "string", then
    1. Let methodNames be «"toString", "valueOf"».
4. Else,
    1. Let methodNames be «"valueOf", "toString"».
5. For each name in methodNames in List order, do
    1. Let method be Get(O, name).
    2. ReturnIfAbrupt(method).
    3. If IsCallable(method) is true, then
       1. Let result be Call(method, O).
       2. ReturnIfAbrupt(result).
       3. If Type(result) is not Object, return result.
6. Throw a TypeError exception.

#### NOTE

 When ToPrimitive is called with no hint, then it generally behaves as if the hint were Number. However, objects may over-ride this behaviour by defining a @@toPrimitive method. Of the objects defined in this specification only Date objects (see 20.3.4.45) and Symbol objects (see 19.4.3.4) over-ride the default ToPrimitive behaviour. Date objects treat no hint as if the hint were String.

### 翻译

Type()是ecma内部实现方法和typeof不一样
没有指定hint期望类型，一般是number

1. 断言 调用Type(O)判断是否是对象
2. 断言 调用Type(hint)判断传入的期望类型是否是字符串，它的值必须是"string"或者 "number"
3. 如果 期望类型 是字符串， 方法名是 "toString", "valueOf"
4. 如果 期望类型 是数字， 方法名是 "valueOf", "toString"
5. 遍历 方法名，生成一个有序数组，开始遍历有序数组
   1. 调用对象上该方法，返回结果
   2. 方法调用失败，跳出
   3. 如果type(结果) 不是对象返回 结果，继续循环
6. 抛出异常 TypeError exception.

例子

```javascript
[1, 2, 3] == '1,2,3'
[1, 2, 3].valueOf() // [1, 2, 3]
[1, 2, 3].toString() //'1,2,3'

let a = {b: 2}
a == "[object Object]"
a.valueOf() // {b: 2}
a.toString() // "[object Object]"
```

```javascript
a = new Date() // Thu May 28 2020 11:05:53 GMT+0800 (中国标准时间)
+a == a // false
typeof a // 'object'
```

```javascript

let user = {
  name: "John",
  money: 1000,

  // 对于 hint="string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // 对于 hint="number" 或 "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
```

```javascript

let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
alert(+user); // valueOf toString -> +"json" => NaN
```

## 小结

实际上，我们没有必要记住这些奇特的细节，除了一种情况（Date 对象）之外，所有内建对象都以和 "number" 相同的方式实现 "default" 转换。我们也可以这样做。

### ===

1. If Type(x) is different from Type(y), return false.
2. If Type(x) is Undefined, return true.
3. If Type(x) is Null, return true.
4. If Type(x) is Number, then
    1. If x is NaN, return false.
    2. If y is NaN, return false.
    3. If x is the same Number value as y, return true.
    4. If x is +0 and y is −0, return true.
    5. If x is −0 and y is +0, return true.
    6. Return false.
5. If Type(x) is String, then
    1. If x and y are exactly the same sequence of code units (same length and same code units at corresponding indices), return true.
    2. Else, return false.
6. If Type(x) is Boolean, then
    1. If x and y are both true or both false, return true.
    2. Else, return false.
7. If x and y are the same Symbol value, return true.
8. If x and y are the same Object value, return true.
9. Return false.

## 总结

对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。

这里有三种类型（hint）：

- "string"（对于 alert 和其他需要字符串的操作）
- "number"（对于数学运算）
- "default"（少数运算符）
规范明确描述了哪个运算符使用哪个 hint。很少有运算符“不知道期望什么”并使用 "default" hint。通常对于内建对象，"default" hint 的处理方式与 "number" 相同，因此在实践中，最后两个 hint 常常合并在一起。

转换算法是：

调用 obj[Symbol.toPrimitive](hint) 如果这个方法存在，
    否则，如果 hint 是 "string"
尝试 obj.toString() 和 obj.valueOf()，无论哪个存在。
    否则，如果 hint 是 "number" 或者 "default"
尝试 obj.valueOf() 和 obj.toString()，无论哪个存在。

在实践中，为了便于进行日志记录或调试，对于所有能够返回一种“可读性好”的对象的表达形式的转换，只实现以 obj.toString() 作为全能转换的方法就够了

## 参考文献

1. <http://www.ruanyifeng.com/blog/2015/11/ecmascript-specification.html>
2. <http://www.ecma-international.org/ecma-262/6.0/#sec-7.2.12>
3. <https://zh.javascript.info/object-toprimitive>
