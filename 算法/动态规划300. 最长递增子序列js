// 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

// 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

// 示例 1：

// 输入：nums = [10,9,2,5,3,7,101,18]
// 输出：4
// 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

/**
 * @param {number[]} nums
 * @return {number}
 */
// 两侧遍历，第一次是所有的，第二层  遍历之前，但是把之前的结果缓存起来，比他大就赋值
//   fn(n) = max(fn(n-1) ... f(1)) + 1
var lengthOfLIS = function (nums) {
  if (!nums.length || !nums) return 0
  let dp = Array(nums.length).fill(1)
  let max = 1
  for (let i = 1; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j] && dp[j] >= dp[i]) {
        dp[i] = dp[j] + 1
      }
    }
    max = Math.max(dp[i], max)
  }
  return max
}

// console.log(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]))
// console.log(lengthOfLIS([7, 7, 7, 7, 7, 7, 7]))
// console.log(lengthOfLIS([0, 1, 0, 3, 2, 3]))

// 考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。

// 基于上面的贪心思路，我们维护一个数组 d[i]d[i] ，表示长度为 ii 的最长上升子序列的末尾元素的最小值，用 \textit{len}len 记录目前最长上升子序列的长度，起始时 lenlen 为 11，d[1] = \textit{nums}[0]d[1]=nums[0]。

// 同时我们可以注意到 d[i]d[i] 是关于 ii 单调递增的。因为如果 d[j] \geq d[i]d[j]≥d[i] 且 j < ij<i，我们考虑从长度为 ii 的最长上升子序列的末尾删除 i-ji−j 个元素，那么这个序列长度变为 jj ，且第 jj 个元素 xx（末尾元素）必然小于 d[i]d[i]，也就小于 d[j]d[j]。那么我们就找到了一个长度为 jj 的最长上升子序列，并且末尾元素比 d[j]d[j] 小，从而产生了矛盾。因此数组 dd 的单调性得证。

// 我们依次遍历数组 \textit{nums}nums 中的每个元素，并更新数组 dd 和 lenlen 的值。如果 \textit{nums}[i] > d[\textit{len}]nums[i]>d[len] 则更新 len = len + 1len=len+1，否则在 d[1 \ldots len]d[1…len]中找满足 d[i - 1] < \textit{nums}[j] < d[i]d[i−1]<nums[j]<d[i] 的下标 ii，并更新 d[i] = \textit{nums}[j]d[i]=nums[j]。

// 根据 dd 数组的单调性，我们可以使用二分查找寻找下标 ii，优化时间复杂度。

// 最后整个算法流程为：

// 设当前已求出的最长上升子序列的长度为 \textit{len}len（初始时为 11），从前往后遍历数组 \textit{nums}nums，在遍历到 \textit{nums}[i]nums[i] 时：

// 如果 \textit{nums}[i] > d[\textit{len}]nums[i]>d[len] ，则直接加入到 dd 数组末尾，并更新 \textit{len} = \textit{len} + 1len=len+1；

// 否则，在 dd 数组中二分查找，找到第一个比 \textit{nums}[i]nums[i] 小的数 d[k]d[k] ，并更新 d[k + 1] = \textit{nums}[i]d[k+1]=nums[i]。

// 以输入序列 [0, 8, 4, 12, 2][0,8,4,12,2] 为例：

// 第一步插入 00，d = [0]d=[0]；

// 第二步插入 88，d = [0, 8]d=[0,8]；

// 第三步插入 44，d = [0, 4]d=[0,4]；

// 第四步插入 1212，d = [0, 4, 12]d=[0,4,12]；

// 第五步插入 22，d = [0, 2, 12]d=[0,2,12]。

// 最终得到最大递增子序列长度为 33。

// tails is an array storing the smallest tail of all increasing subsequences with length i+1 in tails[i].
// For example, say we have nums = [4,5,6,3], then all the available increasing subsequences are:

// len = 1   :      [4], [5], [6], [3]   => tails[0] = 3
// len = 2   :      [4, 5], [5, 6]       => tails[1] = 5
// len = 3   :      [4, 5, 6]            => tails[2] = 6

// We can easily prove that tails is a increasing array.
//  Therefore it is possible to do a binary search in tails array to find the one needs update.

// Each time we only do one of the two:

// (1) if x is larger than all tails, append it, increase the size by 1
// (2) if tails[i-1] < x <= tails[i], update tails[i]
// Doing so will maintain the tails invariant. The the final answer is just the size.

// tails 是有序数组， 二分法，找到  tails[i-1] < x <= tails[i] 这个条件的，如果大于插入到最后

//https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/
// 之前一直没想明白为什么贪心解法里可以用更小的值去替换较大的那一个。举的例子里 [2,3,7,18] 用 4 换掉了 7，这么一来顺序不就不对了吗？

// 后来再仔细想想就搞懂了，其实题解里说得很清楚： tail 不是 LIS，tail 只是长度和 LIS 相等而已。

// [2,3,7,18] --> [2,3,4,18] 之后，如果下一个数字 v >18 ，必然也有 v > 7，所以 tail 长度加 1 是没有问题的；而若 v < 18，那么就需要跟 4 进行比较了，之前的 7 已经没有影响。
var lengthOfLIS2 = function (nums) {
  let tails = []
  let size = 0
  for (let x = 0; x < nums.length; x++) {
    let i = 0
    let j = size
    while (i !== j) {
      let m = Math.floor((i + j) / 2)
      if (tails[m] < nums[x]) {
        i = m + 1
      } else {
        j = m
      }
    }
    tails[i] = nums[x]
    if (i === size) ++size
  }
  return size
}

console.log(lengthOfLIS2([10, 9, 2, 5, 3, 7, 101, 18]))
console.log(lengthOfLIS2([7, 7, 7, 7, 7, 7, 7]))
console.log(lengthOfLIS2([0, 1, 0, 3, 2, 3]))

// var lengthOfLIS = function (nums) {
//   if (!nums.length) return 0
//   const LIS = [nums[0]]
//   for (let i = 1; i < nums.length; i++) {
//     const pos = search(LIS, nums[i])
//     if (pos === LIS.length) {
//       LIS.push(nums[i])
//     } else {
//       LIS[pos] = nums[i]
//     }
//   }
//   return LIS.length
// }

// function search(nums, target) {
//   let start = 0
//   let end = nums.length - 1

//   while (start <= end) {
//     let mid = Math.floor((start + end) >> 1)
//     if (nums[mid] < target) {
//       start = mid + 1
//     } else if (nums[mid] > target) {
//       end = mid - 1
//     } else {
//       return mid
//     }
//   }

//   return start
// }

// var lengthOfLIS = function (nums) {
//   const len = nums.length
//   if (len === 0) {
//     return 0
//   }
//   let f = [nums[0]]
//   // 贪心算法
//   for (let i = 1; i < len; i++) {
//     if (nums[i] > f[f.length - 1]) {
//       f.push(nums[i])
//     } else {
//       // 二分查找都第一个比nums[i]大的数字
//       let [left, right] = [0, f.length - 1]
//       while (left <= right) {
//         let middle = Math.floor((left + right) / 2)
//         if (f[middle] < nums[i]) {
//           left = middle + 1
//         } else {
//           right = middle - 1
//         }
//       }
//       f[left] = nums[i]
//     }
//   }
//   return f.length
// }
