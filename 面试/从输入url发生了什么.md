# 从输入url发生了什么

## 前言

这道题涉及范围广，而且可以很深，简单列步骤，再又浅入深入

1. DNS 解析， 如果有缓存用缓存
2. http链接， 三次握手，四次挥手
3. 链接 返回 页面
4. 解析html， ast， 生成 dom tree 和 css( Cascading Style Sheets) 样式层叠表, 浏览器对我们真的很包容
5. 画layout tree，开始渲染，将dom tree和css，一一对应
6. 建立图层树，生成绘制列表， 栅栏格化， 绘制， 排版，最后出来页面

### 正确姿势

先分成大框架，然后学习细节，层层递进，方便理解和记忆

1. 网络
2. 构建Dom树
3. 样式计算
4. 生成布局树(Layout Tree)
5. 建图层树
6. 绘制

#### 网络

1. 构建请求行
2. 查找强缓存
3. DNS解析
   1. 浏览器提供了DNS数据缓存功能。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 DNS解析
4. 建立TCP连接
   1. 3次握手 4次挥手
5. 发送http请求
   1. 请求行、请求头和请求体
6. 网络响应
   1. 响应行、响应头和响应体

响应完成之后怎么办？TCP 连接就断开了吗？
不一定。这时候要判断Connection字段, 如果请求头或响应头中包含Connection: Keep-Alive，表示建立了持久连接，这样TCP连接会一直保持，之后请求统一站点的资源会复用这个连接。
否则断开TCP连接, 请求-响应流程结束。

![alt](https://user-gold-cdn.xitu.io/2019/12/15/16f080b095268038?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 解析算法篇

1. 构建 DOM 树
   1. HTML文法的本质， 上下文无关文法
   2. 解析算法
      1. 标记化。
      2. 建树。
         1. 将DOM对象加入 DOM 树中。
         2. 将对应标记压入存放开放(与闭合标签意思对应)元素的栈中。
      3. 容错机制
2. 样式计算
   1. 格式化样式表 styleSheets
   2. 标准化样式属性
   3. 计算每个节点的具体样式
3. 计算每个节点的具体样式
   1. 继承， 每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫UserAgent样式。这就是继承规则
   2. 层叠
4. 生成布局树
   1. 遍历生成的 DOM 树节点，并把他们添加到布局树中。属性包含 dispaly:none不会被包进布局树。
   2. 计算布局树节点的坐标位置。

![alt](https://user-gold-cdn.xitu.io/2019/12/15/16f080b2f718e4ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 渲染

1. 建立图层树(Layer Tree)
   1. 显式合成
   2. 隐式合成
2. 生成绘制列表
   1. 接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划
   2. 大家可以在 Chrome 开发者工具中在设置栏中展开 more tools, 然后选择Layers面板，就能看到下面的绘制列表
3. 生成图块并栅格化
   1. 现在开始绘制操作，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫合成线程。
4. 显示器显示内容
   1. 栅格化操作完成后，合成线程会生成一个绘制命令，即"DrawQuad"，并发送给浏览器进程。

浏览器进程中的viz组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。为什么发给显卡呢？我想有必要先聊一聊显示器显示图像的原理。
无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的前缓冲区。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。
看到这里你也就是明白，当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。

![alt](https://user-gold-cdn.xitu.io/2019/12/15/16f080b7b8926b7f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 分层

第一点，拥有层叠上下文属性的元素会被提升为单独的一层。
第二点，需要剪裁（clip）的地方也会被创建为图层。

#### 栅格化

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。

在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。

基于这个原因`合成线程会将图层划分为图块（tile）`，这些图块的大小通常是 256x256 或者 512x512，如下图所示：

然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，
3. 计算出 DOM 节点的样式。创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。为每个图层生成绘制列表，并将其提交到合成线程。
5. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
6. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
7. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### 二刷

1. 导航
   1. 浏览器进程检查url，组装协议，构成完整的url
   2. 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
   3. 拿到ip地址后，检查是否有网络缓存,有并且没有过期返回200，继续使用当前文本
   4. DNS解析，检查是否有DNS缓存
   5. 发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80，https默认443。如果是https请求，还需要建立TLS连接
   6. 构建请求头，请求体
   7. 无，开始导航，触发beforeunload，该事件来取消导航，让浏览器不再执行任何后续工作
   8. 页面并不会马上被替换，有个等待过程，需要等待提交文档阶段，页面内容才会被替换
   9. 检查是否有重定向，content-type类型不同，不同的机制，html，渲染，二进制文件直接渲染
   10. 默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中，但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance
   11. 提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：
       1. 首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
       2. 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
       3. 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
       4. 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。
   12. 开始渲染

### 问题

#### <https://linkmarket.aliyun.com>内新开的页面都是新开一个渲染进程，能帮忙解释下吗

我看了下代码，因为连接里面使用了 rel="noopener noreferrer"这个属性。

这个涉及到安全了，要完整解释起来就话长了，我长话短说，先看阿里这个网站的连接是下面这种形式：

<a target="_blank" rel="noopener noreferrer" class="hover" href="https://linkmarket.aliyun.com/hardware_store?spm=a2c3t.11219538.iot-navBar.62.4b5a51e7u2sXtw" data-spm-anchor-id="a2c3t.11219538.iot-navBar.62">硬件商城</a>

使用noopener noreferrer就是告诉浏览器，新打开的子窗口不需要访问父窗口的任何内容，这是为了防止一些钓鱼网站窃取父窗口的信息。

浏览器在打开新页面时，解析到含有noopener noreferrer时，就知道他们不需要共享页面内容，所以这时候浏览器就会让新链接在一个新页面中打开了。

### 同一站点共用一个渲染进程，那假设有2个标签页是同一站点，我在A标签页面写个死循环，导致页面卡死，B页面是否也是卡死了呢？

作者回复: 你能想到这个问题，说明你已经快思考到最核心的---事件循环机制了，非常好。

多个页面公用一个渲染进程，也就意味着多个页面公用同一个主线程，所有页面的任务都是在同一个主线程上执行，这些任务包括渲染流程，JavaScript执行，用户交互的事件的响应等等，@@@但是@@@ 如果一个标签页里面执行一个死循环，那么意味着该JavaScript代码会一直霸占主线程，这样就导致了其它的页面无法使用该主线程，从而让所有页面都失去响应！

关于循环系统，

例子
在同一域名打开两个tap，刚开始是两个tab卡住，慢慢整个浏览器变卡，不是一瞬间就卡住了，优化做的不错
在控制台输入一下代码：

```js
for(;;) {
console.log(Math.pow(2, 100))
}

```

## 总结

### 参考文献

1. <https://juejin.cn/post/6844904021308735502#heading-26>
2. <https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context>
