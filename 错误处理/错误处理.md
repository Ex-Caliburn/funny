# 异常处理

## 前言

前端总是会有这种个样的问题，你不能等到用户提bug才去解决问题，你需要提前发现问题，并且询问用户操作路径时间成本也高

### 错误类型

### SyntaxError

不能被捕获的，但是构建的时候会被发现

```js
const a 
// Uncaught SyntaxError: Missing initializer in const declaration
```

### TypeError

onerror 捕获

```js
const person = void 0
person.name
// Uncaught TypeError: Cannot read properties of undefined (reading 'name')
```

### ReferenceError

onerror 捕获

```js
nodefined
// Uncaught ReferenceError: nodefined is not defined
```

### RangeError

onerror 捕获

```js
(function fn ( ) { fn() })()
// Uncaught RangeError: Maximum call stack size exceeded
```

### resourceError

资源上的onerror

```js
  let b= new Image()
  b.onerror = (err) => {
      console.log('Image', err)
  }
  b.src = '/remote/image/notdeinfed.png'
```

```html
<img src="images/logo.png" onerror="javascript:this.src='images/logoError.png';">
```

当一项资源（如<img>或<script>）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数。这些error事件不会向上冒泡到window，不过（至少在Firefox中）能被单一的window.addEventListener (en-US)捕获。

标签的error (后来发现其实是可以带的)，是个回调事件！！！

### HttpError

unhandledrejection

```js
fetch('/remote/notdefined', {})
```

### try catch

try catch 抛错 是一个error 对象， 如下所示

```js
{
  message: "a is not defined" // 错误信息
  stack: '...' // 错误栈
}
```

```js
try {
  console.log(a.b)
  } catch (error) {
    console.log(error) // ReferenceError: a is not defined
  }

    try {
      setTimeout(() => {
        console.log(a.b)
      }, 100)
    } catch (err) {
      console.log(err) // 不会有任何反应
    }

```

注意 try catch 捕获的异常，不会继续冒泡了，不会触发到window的 onerror
主要将 try catch 用于 知道某个地方会报错的地方，进行特殊化处理，

#### 缺点

不能捕获 异步错误

### error

当`JavaScript`运行时错误（包括语法错误）发生时，`window`会触发一个`ErrorEvent`接口的`error`事件，并执行`window.onerror()`。

当一项资源（如`<img>`或`<script>`）加载失败，加载资源的元素会触发一个`Event`接口的`error`事件，并执行该元素上的`onerror()`处理函数。这些`error`事件不会向上冒泡到`window`，不过（至少在`Firefox`中）能被单一的`window.addEventListener`捕获。

有3种监听方式，主要参数不一样一个

```js
window.onerror = function(message, source, lineno, colno, error) { ... }

window.addEventListener('error', function(event) { ... })
// ErrorEvent 类型的event包含有关事件和错误的所有信息。

element.onerror = function(event) { ... }
// element.onerror使用单一Event参数的函数作为其处理函数。
```

例子

```js
window.onerror = function(message, source, lineno, colno, error) {
  console.log(message, source, lineno, colno, error)
 }

 setTimeout(() => {
        console.log(a.b) // 捕获
      }, 100)

// promise
let work = function () {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
         console.log(a.b) // 无法捕获
        resolve(111)
      }, 11)
    })
  }

  work()
    .then((res) => {
      console.log(res)
    })

```

#### error 缺点

error 也有缺点，就是它不能捕获 promise 错误

#### unhandledrejection

当Promise 被 reject 且没有 reject 处理器的时候，会触发 unhandledrejection 事件；这可能发生在 window 下，但也可能发生在 Worker 中。 这对于调试回退错误处理非常有用。

unhandledrejection 继承自 PromiseRejectionEvent，而 PromiseRejectionEvent 又继承自 Event。因此unhandledrejection 含有 PromiseRejectionEvent 和 Event 的属性和方法。

用法

```js
 window.addEventListener('unhandledrejection', function (event) {
        console.log(event)
        // event 是 PromiseRejectionEvent 对象
        // event.reason原因 和error一样
      })
```

例子

```js
// promise
let work = function () {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
         console.log(a.b) // 捕获
        resolve(111)
      }, 11)
    })
  }

  work()
    .then((res) => {
      console.log(res)
    })

    work()
    .then((res) => {
      console.log(res)
    }).catch(err => {
      console.log(err) // 被catch 捕获，不会被 unhandledrejection捕获
    })

    async function ajax() {
        console.log(a.b)
        let res = await work()
    }
    ajax()

```

#### unhandledrejection注意

promise 和 async内的报错都会被捕获到， 如果添加了 catch, unhandledrejection也捕获不到

如下所示

```js
ajax().then(res => {
        console.log(res)
      }).catch(err => {
        console.log(err)
      })
```

### script error

我们先来复现
参照 [这片文章](https://juejin.im/post/5c00a405f265da610e7fd024#heading-0)
点击3000按钮

```js
error 捕获
Error: Fail 3000
    at HTMLButtonElement.<anonymous> (<http://127.0.0.1:3000/at3000.js:3:9)>

console控制台
at3000.js:3 Uncaught Error: Fail 3000
at HTMLButtonElement.<anonymous> (at3000.js:3)
```

点击4000按钮

```js
error 捕获 复现了 !!!
Script error.

console控制台
at4000.js:3 Uncaught Error: Fail 4000
at HTMLButtonElement.<anonymous> (at4000.js:3)
```

#### 为什么会抛出这个错误

当加载自不同域的脚本中发生语法错误时，为避免信息泄露（参见bug [363897](https://bugzilla.mozilla.org/show_bug.cgi?id=363897)），语法错误的细节将不会报告，而代之简单的`"Script error."`。在某些浏览器中，通过在`script`使用`crossorigin`属性并要求服务器发送适当的 `CORS HTTP` 响应头，该行为可被覆盖。一个变通方案是单独处理`"Script error."`，告知错误详情仅能通过浏览器控制台查看，无法通过`JavaScript`访问。

#### 解决方案

1. script标签 加crossorigin="anonymous" 服务器设置 access-control-allow-origin="*" 或者资源文件的域名
2. 可以捕获  Script error，但是不可能每个函数包装，vue把函数执行包在try catch里执行

#### crossorigin="anonymous" 缺点

如果 JS 声明了 crossorigin="anonymous" 但是响应头没有正确，JS 会直接无法执行
我们并不总是有静态服务器的配置权限，跨域头不是想加就能加

### 上报接口

为什么不能直接用GET/POST/HEAD请求接口进行上报？

这个比较容易想到原因。一般而言，打点域名都不是当前域名，所以所有的接口请求都会构成跨域。

为什么不能用请求其他的文件资源（js/css/ttf）的方式进行上报？

创建资源节点后只有将对象注入到浏览器DOM树后，浏览器才会实际发送资源请求。而且载入js/css资源还会阻塞页面渲染，影响用户体验。

构造图片打点不仅不用插入DOM，只要在js中new出Image对象就能发起请求，而且还没有阻塞问题，在没有js的浏览器环境中也能通过img标签正常打点。

使用new Image进行接口上报。最后一个问题，同样都是图片，上报时选用了1x1的透明GIF，而不是其他的PNG/JEPG/BMP文件。

首先，1x1像素是最小的合法图片。而且，因为是通过图片打点，所以图片最好是透明的，这样一来不会影响页面本身展示效果，二者表示图片透明只要使用一个二进制位标记图片是透明色即可，不用存储色彩空间数据，可以节约体积。因为需要透明色，所以可以直接排除JEPG。

同样的响应，GIF可以比BMP节约41%的流量，比PNG节约35%的流量。GIF才是最佳选择。

- 可以进行跨域
- 不会携带cookie
- 不需要等待服务器返回数据
使用1*1的gif

### 将错误数据上报

1. ajax 耗费前端资源，占用连接数
2. 一种是构造空的Image对象的方式，其原因是请求图片并不涉及到跨域的问题； 推荐, 因为绝大多数用户代理会延迟卸载以保证图片的载入

```js
new Image().src = url;
```

3. 还有时合并上报， 需要页面upload 事件时发送，用ajax 会导致页面延迟关闭,使用HEAD请求，接口返回空的结果，最大地减少上报日志造成的资源浪费。

```js
window.addEventListener('unload', logData, false);

function logData() {
    navigator.sendBeacon("/log", analyticsData);
}
```

#### XMLHttpRequest

XMLHttpRequest 报错的话， XMLHttpRequest.onerror 可以捕获，unhandledrejection 和 window.onerror 无法捕获

用promise 包裹的话 报错的话，unhandledrejection可以捕获，

#### sendBeacon

不想每次都上报错误，集合上报怎么办？

使用 sendBeacon() 方法会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：数据可靠，传输异步并且不会影响下一页面的加载。此外，代码实际上还要比其他技术简单许多！

sendBeacon本质是http post 请求

```js
navigator.sendBeacon(url, data);
```

data 参数是将要发送的 ArrayBufferView 或 Blob, DOMString 或者 FormData 类型的数据。

```javascript
function logData() {
    navigator.sendBeacon("/log", analyticsData);
}
```

### vue 错误处理

组件钩子, 当捕获一个来自子孙组件的错误时被调用,自己组件报错无法捕获
errorCaptured

可以捕获错误，捕获后会发送给全局的config.errorHandler， 此钩子可以返回 false 以阻止该错误继续向上传播。

全局钩子
Vue.config.errorHandler

js正则错误无法捕获 safari 下
'11'.match(/(?<=T).{5}/)[0]
SyntaxError: Invalid regular expression

组件生命周期
errorCaptured(err: Error, instance: Component, info: string) => ?boolean

不能捕获 `<template></template>` 报错

源码

```javascript
function handleError (err, vm, info) {
    // 当处理错误时，使深度追踪失效，避免可能的无限渲染
    // See: <https://github.com/vuejs/vuex/issues/1505>
    pushTarget();
    try {
      if (vm) {
        var cur = vm;
        // 遍历自己父组件，找到errorCaptured 方法
        // 如果errorCaptured返回false，不继续冒泡到全局 Vue.config.errorHandler,默认 返回undefined
        while ((cur = cur.$parent)) {
          var hooks = cur.$options.errorCaptured;
          if (hooks) {
            for (var i = 0; i < hooks.length; i++) {
              try {
                var capture = hooks[i].call(cur, err, vm, info) === false;
                if (capture) { return }
              } catch (e) {
                globalHandleError(e, cur, 'errorCaptured hook');
              }
            }
          }
        }
      }
      globalHandleError(err, vm, info);
    } finally {
      popTarget();
    }
  }
  ```

### Webpack插件实现SourceMap上传

是将webpack混淆压缩的代码还原
将打包结束后的代码上传
还需要记录版本，应该发版后错误的地址就发生了变化，是不是要存发版的历史文件

1. 在apply函数中增加读取sourcemap文件的逻辑
2. 上传被上传至服务器
3. 将错误记入日志
4. 解析ErrorStack
5. 反序列Error对象：首先创建一个新的Error对象 将错误栈设置到Error中。然后利用error-stack-parser这个npm库来转化为stackFrame
6. 我们将错误栈中的代码位置转换为源码位置
7. 记录到错误日志

## 总结

因为有各种个样的错误处理机制，js才越来越健壮
作为前端开发者而言，要对产品保持敬畏之心，时刻保持对性能追求极致，对异常不可容忍的态度。前端的性能监控与异常上报显得尤为重要。
也可以使用业内成熟方案 Sentry

### 参考文献

1. <https://juejin.im/post/5c00a405f265da610e7fd024#heading-0>
2. <https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onerror>
3. <https://developer.mozilla.org/zh-CN/docs/Web/Events/unhandledrejection>
4. <https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon>
5. <https://developer.mozilla.org/zh-CN/docs/Web/API/Beacon_API/Using_the_Beacon_API>
6. <https://usefulangle.com/post/63/javascript-navigator-sendbeacon-set-form-http-header>
7. <https://www.zhihu.com/people/15601381285/posts>
8. <https://mp.weixin.qq.com/s/TzTmu5FS5XGDgQKcLbNqgw>
