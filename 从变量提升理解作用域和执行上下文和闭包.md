# var

## 前言

用 var 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，或者对于声明在任何函数外的变量来说是全局
当赋值给未声明的变量, 则执行赋值后, 该变量会被隐式地创建为全局变量（它将成为全局对象的属性）。

### 作用域和执行上下文

作用域： 全局作用域,函数作用域,块级作用域（es6引入，如if，switch语句）
作用: 最大的用处就是隔离变量，不同作用域下同名变量不会有冲突; 用于变量的查找
历史因素
js 是脚本语言(先解释再运行)，在脚本运行时，先解析，先创建一个全局作用域，当遇到var 变量时时创建一个栈空间，当赋值给未声明的变量， 该变量会变量提升，提升指js最上层，如果遇到函数，因为是引用类型会创建一个堆空间,函数也将变量提升，并创建函数作用域, 如果是var a = function c() {},函数将不会提升，等到运行才生成函数作用域,作用域是静态的，是在v8引擎解释时就创建了，而执行上下文时运行时创建的，所以函数作用域不随函数调用位置变化而变化，但是执行上下文是栈操作，先进后出

上下文：主要是关键字this的值，这个是由函数运行时决定的，简单来说就是谁调用此函数，this就指向谁
上下文栈，先进后出，全局有上下文，函数也是上下文，执行完，出栈，闭包除外

函数提升仅适用于函数声明，而不适用于函数表达式。
函数作用域，你可以访问外部变量，外部不能访问你。函数中的变量所存放的空间是堆，当函数被使用后，失去引用时，函数的变量就会被内存回收并销毁。而闭包，不会销毁，生成单独的上下文，不会被销毁，如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响，因为函数内部存在外部引用，垃圾回收机制，引用计数不会被清零，也就是函数不会被销毁。不是闭包的话，函数执行完毕，执行上下文出栈，同时变量将会回收

区别1
1). 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
2). 上下文环境是动态的, 调用函数时创建, 函数调用结束时上下文环境就会被释放
区别2
1). 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时
2). 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建
3). 函数执行上下文环境是在调用函数时, 函数体代码执行之前创建

### 声明和未声明变量之间的差异

1. 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。
2. 声明变量在任何代码执行前创建，而非声明变量只有在执行赋值操作的时候才会被创建。

```
console.log(a);                // 抛出ReferenceError。

var a;
console.log(a);                // 打印"undefined"或""（不同浏览器实现不同）。
```

3. 声明变量是它所在上下文环境的不可配置属性，非声明变量是可配置的（如非声明变量可以被删除）

```
var a = 1;
b = 2;

delete this.a; // 在严格模式（strict mode）下抛出TypeError，其他情况下执行失败并无任何提示。
delete this.b;

console.log(a, b); // 抛出ReferenceError。
// 'b'属性已经被删除。
```

### 变量提升

由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。这意味着变量可以在声明之前使用，这个行为叫做“hoisting”。“hoisting”就像是把所有的变量声明移动到函数或者全局代码的开头位置。

### 闭包

优点: 安全性，外部作用域无法访问闭包内的变量和函数; 实现模块化， 将所有的数据和功能都封装在一个函数内部(私有的)，只向外暴露一个对象(函数), 并给对象添加一些公开的方法
缺点： 内存泄漏

闭包必要条件： 函数嵌套函数，内部函数引用外部变量

1. 函数嵌套函数，不一定产生闭包，内部函数访问外部函数作用域,因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数的生存周期将比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。 当一个函数（foo）执行返回一个内部函数（bar）引用时，bar 将会保存 foo 的作用域引用

```
一
function foo() {
    const str = "bar in foo";
    return function bar() {
        return str;
    }
}
var fun = foo();
二
var pet = function(name) {          //外部函数定义了一个变量"name"
  var getName = function() {
    //内部函数可以访问 外部函数定义的"name"
    return name;
  }
  //返回这个内部函数，从而将其暴露在外部函数作用域
  return getName;
};
myPet = pet("Vivie"); // 如果把myPet的引入消除 myPet = null，闭包之后会被回收

myPet();
```

2. 立即执行函数也不一定是闭包

```
 let single = (function () {
     let name = "小明";
     let age = 20;
     return {
         getName: function () {
             return name;
         },
         getAge: function () {
             return age;
         }
     }
 })();
 console.log(single.getName()); //小明
 console.log(single.getAge()); //20
```

### bind call

调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。

```
const module = {
  x: 42,
  getX: function() {
    return this.x;
  }
}

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// expected output: undefined

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// expected output: 42
```

### 参考文献

1. <https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var>
