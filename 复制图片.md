# 复制图片到剪切板

## 前言

检验权限

```ts
async function isSupportClipboardWrite() {
  try {
    const permission = await navigator.permissions.query({
      name: "clipboard-write" as PermissionName,
      allowWithoutGesture: false,
    };
    return ["prompt", "granted"].includes(permission.state);
  } catch (error) {
    return false;
  }
}

// 获取图片dom
function getImgDom(url: string) {
  return new Promise<HTMLImageElement>((resolve, reject) => {
    const img = document.createElement("img");
    img.src = url;
    img.onload = function () {
      resolve(img);
    };
    img.onerror = function (err) {
      console.log(err);
      reject();
    };
  });
}

function getBlob(url: string) {
  return axios
    .get(url, {
      responseType: "blob",
    })
    .then(
      response => {
        return Promise.resolve(response.data);
      },
      err => {
        console.log(err);
        return Promise.reject();
      }
    );
}

let _canvasLoading = false;
export async function htmlToImage(imgUrl: string, isCopy = false, name: string, isBlob = false) {
  if (_canvasLoading) {
    message.error("正在下载中，请稍后尝试");
    return;
  }
  // canvas 画图
  _canvasLoading = true;
  let htmlEl: HTMLImageElement;
  if (isBlob) {
    const blob = await getBlob(imgUrl);
    htmlEl = await getImgDom(URL.createObjectURL(blob));
  } else {
    htmlEl = await getImgDom(imgUrl);
  }

  if (!htmlEl) {
    _canvasLoading = false;
    return;
  }
  console.log(htmlEl);
  document.body.append(htmlEl);
  // <https://github.com/niklasvh/html2canvas/issues/1951> 参考配置，避免内容高度大于窗户高度导致截图不全的问题
  html2canvas(htmlEl, {
    scale: 1, // window.devicePixelRatio 默认为浏览器的像素比，浏览器缩放会影响下载分辨率，这里固定为1
    useCORS: true, // 用于图片跨域
    scrollX: -window.scrollX,
    scrollY: -window.scrollY,
    windowWidth: document.documentElement.offsetWidth,
    windowHeight: document.documentElement.offsetHeight,
  })
    .then(
      canvas => {
        _output(canvas, isCopy, name);
      },
      err => {
        console.log("生成图片失败:", err);
        message.error("生成图片失败");
      }
    )
    .finally(() => {
      document.body.removeChild(htmlEl);
      _canvasLoading = false;
    });
}

async function _output(canvas: HTMLCanvasElement, isCopy: boolean, imageName: string) {
  if (!isCopy) {
    downloadImg(canvas.toDataURL(), imageName);
    return;
  }
  const isSupportCopy = await isSupportClipboardWrite();
  if (!isSupportCopy) {
    const img = new Image();
    img.src = canvas.toDataURL();
    const newWin = <Window>window.open("", "_blank");
    newWin.document.write(img.outerHTML);
    newWin.document.title = "流程图";
    newWin.document.close();
    message.error("该浏览器不支持复制到粘贴板");
    return;
  }
  const selection = window.getSelection();
  const range = document.createRange();
  const dom = document.createElement("span");
  document.body.append(dom);
  range.selectNode(dom);
  (selection as Selection).removeAllRanges();
  (selection as Selection).addRange(range);
  const data = [
    new (window as any).ClipboardItem({
      "image/png": <any>base64ToBlob(canvas.toDataURL()),
    }),
  ];
  (navigator.clipboard as any)
    .write(data)
    .then(
      () => {
        message.success("复制成功");
      },
      (err: any) => {
        message.error(`复制失败:${err}`);
        console.log("err", err);
      }
    )
    .finally(() => {
      document.body.removeChild(dom);
    });
}

/* 将图片下载到本地 */
export function downloadImg(content: string, fileName: string) {
  const aLink = document.createElement("a");
  const blob = base64ToBlob(content); // new Blob([content]);
  const evt = document.createEvent("HTMLEvents");
  evt.initEvent("click", true, true); // initEvent 不加后两个参数在FF下会报错  事件类型，是否冒泡，是否阻止浏览器的默认行为
  aLink.download = fileName;
  aLink.href = URL.createObjectURL(blob);
  aLink.click();
  // URL.revokeObjectURL(<any>blob);
}

/*  base64转blob */
export function base64ToBlob(code: string) {
  const parts = code.split(";base64,");
  const contentType = parts[0].split(":")[1];
  const raw = window.atob(parts[1]);
  const rawLength = raw.length;
  const uInt8Array = new Uint8Array(rawLength);
  for (let i = 0; i < rawLength; ++i) {
    uInt8Array[i] = raw.charCodeAt(i);
  }
  return new Blob([uInt8Array], {
    type: contentType,
  });
}
```

### Document.execCommand()

方法虽然方便，但是有一些缺点
首先，它只能将选中的内容复制到剪贴板，无法向剪贴板任意写入内容。
其次，它是同步操作，如果复制/粘贴大量数据，页面会出现卡顿。有些浏览器还会跳出提示框，要求用户许可，这时在用户做出选择前，页面会失去响应。

### copy 事件，cut 事件

不支持图片
用户向剪贴板放入数据时，将触发copy事件。

下面的示例是将用户放入剪贴板的文本，转为大写。

```js
const source = document.querySelector('.source');

source.addEventListener('copy', (event) => {
  const selection = document.getSelection();
  event.clipboardData.setData('text/plain', selection.toString().toUpperCase());
  event.preventDefault();
});
```

## 总结

截止当前只支持png格式图片粘贴到剪切板
浏览器兼容性 firefox不行，这个竟然落下风了

### 参考文献

1. <https://web.dev/async-clipboard/>
2. <https://www.ruanyifeng.com/blog/2021/01/clipboard-api.html>
