# 单线程

## 前言

为什么说页面是单线程架构？

默认情况下每个标签页都会配套一个渲染进程，而一个渲染进程里不是有主线程、合成线程、IO线程等多个线程吗

是因为【排版引擎 blink】 和【JavaScript引擎 v8】都工作在渲染进程的主线程上并且是互斥的，基于这点说页面是单线程架构？
作者回复: 是的，他们都是在渲染进程的主线程上工作，所以同时只能执行一个。

比如v8除了在主线程上执行JavaScript代码之外，还会在主线程上执行垃圾回收，所以执行垃圾回收时停止主线程上的所有任务，我们把垃圾回收这个特性叫着全停顿。

脚本任务 将会由 v8 模块所在的线程（js线程）执行；界面渲染任务则会由 webkit 模块所在线程（渲染线程）执行；而 HTTP 任务则会由 网络进程 中的 网络线程执行。我们都知道 js 的长时间执行会导致界面卡顿、js线程与渲染线程互斥，其本质是 脚本任务 作为 current running task 执行过长时间，渲染任务 无法成为 currrent running task 导致。

关于这个任务执行的调度算法，需要知道：
0. 调度算法综合很多的因素：队列的权重、队列内任务的等待时间、任务类型（宏/微）等

1. User InteractionTask Queue 这个 queue 比其他的 queue 有着更高的优先级。以便能够更流畅的响应界面交互；
2. 每次执行完一个宏任务之后，就会循环所有的微任务，并依次将他们执行完毕，直至微任务队列清空
3. 任务有很多种，有脚本执行，还有界面渲染等

事件循环中，有一个 current running task 的引用。它引用就是当前正在执行的任务。事实上浏览器的事件循环是有一个调度算法的。每次从 众多的 queue 当中选取一个任务出队，然后将 current running task 设置为这个任务。接下来通过js 引擎的预编译(字节码)以及逐行解析，在执行栈当中产生了 Execution Context 的堆栈（这个老师讲的很好）。有些资料认为这个执行栈就是 “同步队列”，这是大错特错的。需要注意。

首先 浏览器 并没有 消息队列 的概念。有的只是 任务队列。而且 任务队列 不止一个。不同类型的事件触发后，相应的任务会推入到不同的任务队列当中。如用户的 鼠标事件、定时器事件、HTTP 回调事件 等等，其对应的 任务队列 分别为 User Interaction
Task Queue、Timer Callback Task Queue、HTTP Callback Task Queue。注意，这些事件如果不触发，相应的任务就不会入队，也就得不到 js 引擎的执行。

## 总结

### 参考文献
