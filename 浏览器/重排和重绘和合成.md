# 重排和重绘和合成

## 前言

1. 更新了元素的几何属性（重排）你可先参考下图：更新元素的几何属性从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

![alt](https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png)

1. 更新元素的绘制属性（重绘）接下来，我们再来看看重绘，比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：更新元素背景从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

![alt](https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png)

1. 直接合成阶段那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图：避开重排和重绘在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。至于如何用这些概念去优化页面，我们会在后面相关章节做详细讲解的，这里你只需要先结合“渲染流水线”弄明白这三个概念及原理就行。
![alt](https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png)

## 问题

你能总结出来为什么减少重绘、重排能优化 Web 性能吗？那又有那些具体的实践方法能减少重绘、重排呢？

1. 减少重绘，重排，极大减少了重新计算布局和分层，生成layout tree 绘制的时间

方法

1. 设置will-change:transform后使用transform
2. 使用 class 操作样式，而不是频繁操作 style和dom
3. 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React，vue 的vnode
4. 使要变化样式的放在单一图层，提升图层，不影响其他的布局

canvas的渲染流程是什么样的呢？它不涉及dom，也就不涉及dom树、样式计算、布局、分层，canvas的绘制过程也是在渲染进程中进行的吗？
回复: canvas绘制流程很简单，就是调用api直接在画布上绘制，没有DOM，也没有太多套路！

所有的绘制都是自己程序控制的

### 参考文献
