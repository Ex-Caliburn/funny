# 箭头函数

## 前言

### 和普通函数的区别

1. 没有自己的绑定指向this或者super
2. 没有new.target 关键字
3. 没有call, apply 和 bind 方法，他们通常都依赖于建立作用域
4. 不能当作constructors
5. 函数体内不能使用yield
  
### 不能调用super

super 关键字 用于访问和调用 一个object的父亲上的函数

在class 和字面量对象的方法中，super.prop 和 super[expr] 都有效

Syntax

```js
super([arguments]); // calls the parent constructor.
super.functionOnParent([arguments]);
```

```js
var obj1 = {
  method1: () => {
    console.log('method 1');
  }
}

var obj2 = {
  method2: ()=> {
    super.method1(); // error
  }
  method3: ()=> {
    super.method1(); 
  }
}

Object.setPrototypeOf(obj2, obj1);
obj2.method2(); // error
obj2.method3(); // logs "method 1"
```

### new.target

正常函数调用 new.target是undefined,通过new 调用，new.target的值是 constructor

```js
function Foo() {
  if (!new.target) { throw 'Foo() must be called with new' }
  console.log('Foo instantiated with new')
}

new Foo()  // logs "Foo instantiated with new"
Foo()      // throws "Foo() must be called with new"
```

class new.target的值是 是 new 背后的 constructor

```js
class A {
  constructor() {
    console.log(new.target.name)
  }
}

class B extends A { constructor() { super() } }

let a = new A()  // logs "A"
let b = new B()  // logs "B"

class C { constructor() { console.log(new.target)  } }
class D extends C { constructor() { super()  } }

let c = new C()  // logs class C{constructor(){console.log(new.target);}}
let d = new D()  // logs class D extends C{constructor(){super();}}
```

箭头函数new.target继承他所包围的作用域
In arrow functions, new.target is inherited from the surrounding scope.

```js
 let Foo = ()=> {
    console.log(new.targnewet) // new.target expression is not allowed here
  }

function b() {
  console.log(new.target)
  let Foo = ()=> {
    console.log(new.target)
  }
  return Foo
}
let a = b()
a() // undefined

let c = new b()
c() // function b()

```

### 没有call, apply 和 bind 方法

```js
// A simplistic object with its very own "this".
var obj = {
    num: 100
}

// Setting "num" on window to show how it gets picked up.
window.num = 2020; // yikes!

// Arrow Function
var add = (a, b, c) => this.num + a + b + c;

// call
console.log(add.call(obj, 1, 2, 3)) // result 2026

// apply
const arr = [1, 2, 3]
console.log(add.apply(obj, arr)) // result 2026

// bind
const bound = add.bind(obj)
console.log(bound(1, 2, 3)) // result 2026
```

### 没有绑定arguments对象

箭头函数内的arguments指向了外围的 arguments

```js
var arguments = [1, 2, 3];
var arr = () => arguments[0];

arr(); // 1

function foo(n) {
  var f = () => arguments[0] + n; // foo's implicit arguments binding. arguments[0] is n
  return f();
}

foo(3); // 3 + 3 = 6
```

### 使用 new

Arrow functions cannot be used as constructors and will throw an error when used with new.

```js
var Foo = () => {};
var foo = new Foo(); // TypeError: Foo is not a constructor 
```

### 使用 prototype

Arrow functions do not have a prototype property.

```js
var Foo = () => {};
console.log(Foo.prototype); // undefined
```

### Use of the yield keyword

yield 关键字 不能写在在箭头函数体内（除非允许函数进一步嵌套在它里面)，可以推论出， 箭头函数不能当作 generators

The yield keyword may not be used in an arrow function's body (except when permitted within functions further nested within it). As a consequence, arrow functions cannot be used as generators.

## 总结

### 参考文献
