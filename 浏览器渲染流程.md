# 浏览器渲染流程

## 前言

了解渲染机制，提升自己薄弱环节

### 渲染大概流程

- 构建 DOM树
  - 建树算法
  - 容错机制  eg:html可以只写一段文本，自动添加 tbody
- 样式计算
  - 格式化样式表 其转化为一个结构化的对象，document.styleSheets来查看这个最终的结构
  - 标准化样式属性 每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫UserAgent样式。这就是继承规则，非常容易理解。
- 生成布局树(Layout Tree)
  - 遍历生成的 DOM 树节点，并把他们添加到布局树中。
  - 计算布局树节点的坐标位置。
- 建立图层树(Layer Tree)
  - 节点的图层会默认属于父亲节点的图层(这些图层也称为合成层)。那什么时候会提升为一个单独的合成层呢
  - 显式合成 HTML根元素本身就具有层叠上下文。
    - 普通元素设置position不为static并且设置了z-index属性，会产生层叠上下文。
    - 元素的 opacity 值不是 1
    - 元素的 transform 值不是 none
    - 元素的 filter 值不是 none
    - 元素的 isolation 值是isolate
    - will-change指定的属性值为上面任意一个。(will-change的作用后面会详细介绍)
  - 隐式合成
    - 接下来是隐式合成，简单来说就是层叠等级低的节点被提升为单独的图层之后，那么所有层叠等级比它高的节点都会成为一个单独的图层。
- 生成绘制列表
  - 渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划
- 生成图块并栅格化
- 显示器显示内容

## reflow(重绘), repaint(重排), 合成

### 重绘

简单来说，就是当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生回流的过程。
有以下的操作会触发回流:

- 一个 DOM 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等, 这个很好理解。
- 使 DOM 节点发生增减或者移动。
- 读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作。
- 调用 window.getComputedStyle 方法。
  
依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍

![alt](https://user-gold-cdn.xitu.io/2019/12/15/16f0809e65b3d2fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

相当于将解析和合成的过程重新又走了一篇，开销是非常大的。

### 重排

当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)。

由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。流程如下：

跳过了生成布局树和建图层树的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。

可以看到，重绘不一定导致回流，但回流一定发生了重绘。

### 合成

还有一种情况，是直接合成。比如利用 CSS3 的transform、opacity、filter这些属性就可以实现合成的效果，也就是大家常说的GPU加速。
GPU加速的原因
    - 在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理。交给它处理有两大好处:
    - 能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而GPU 是擅长处理位图数据的。
    - 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。

## 概念解读

　DOM Tree：浏览器将HTML解析成树形的数据结构。

　CSS Rule Tree：浏览器将CSS解析成树形的数据结构。

　Render Tree: DOM和CSSOM合并后生成Render Tree。

　layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。

　painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。

　reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。

　repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。

### 注意

- display:none 的节点不会被加入Render Tree，而visibility: hidden则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。
- display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。
- 有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如resize窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。

### 实践意义

知道上面的原理之后，对于开发过程有什么指导意义呢？

- 避免频繁使用 style，而是采用修改class的方式。
- 使用createDocumentFragment进行批量的 DOM 操作。
- 对于 resize、scroll 等进行防抖/节流处理。
- 添加 will-change: transform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个- 变化不限于transform, 任何可以实现合成效果的 CSS 属性都能用will-change来声明。这里有一个实际的例子

## 总结

css和渲染流程真的很多东西得消化

## 参考文献

1. <https://segmentfault.com/a/1190000014520786>
2. <https://juejin.im/post/5df5bcea6fb9a016091def69#heading-41>
3. <https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change>
